owner_mrn: //policy.api.mondoo.app
policies:
- uid: kubernetes-best-practices
  name: Kubernetes Best Practices Benchmark by Mondoo
  version: 1.0.0
  is_public: true
  authors:
    - name: Mondoo, Inc
      email: hello@mondoo.com
  docs:
    desc: |-
      The Kubernetes Best Practices Benchmark by Mondoo provides guidance for establishing reliable Kubernetes clusters by encouraging the adoption of best practices.
 
      If you have questions, comments, or have identified ways to improve this policy, please write us at hello@mondoo.io, or reach out in [GitHub Discussions](https://github.com/orgs/mondoohq/discussions).
  specs:
  - asset_filter:
      query: platform.name == "k8s-cronjob"
    scoring_queries:
      kubernetes-best-practices-cronjob-requestcpu:
      kubernetes-best-practices-cronjob-requestmemory:
      kubernetes-best-practices-cronjob-livenessprobe:
      kubernetes-best-practices-cronjob-readinessProbe:
      kubernetes-best-practices-cronjob-hostalias:
      kubernetes-best-practices-cronjob-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-statefulset"
    scoring_queries:
      kubernetes-best-practices-statefulset-requestcpu:
      kubernetes-best-practices-statefulset-requestmemory:
      kubernetes-best-practices-statefulset-livenessprobe:
      kubernetes-best-practices-statefulset-readinessProbe:
      kubernetes-best-practices-statefulset-hostalias:
      kubernetes-best-practices-statefulset-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-deployment"
    scoring_queries:
      kubernetes-best-practices-deployment-requestcpu:
      kubernetes-best-practices-deployment-requestmemory:
      kubernetes-best-practices-deployment-livenessprobe:
      kubernetes-best-practices-deployment-readinessProbe:
      kubernetes-best-practices-deployment-hostalias:
      kubernetes-best-practices-deployment-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-job"
    scoring_queries:
      kubernetes-best-practices-job-requestcpu:
      kubernetes-best-practices-job-requestmemory:
      kubernetes-best-practices-job-livenessprobe:
      kubernetes-best-practices-job-readinessProbe:
      kubernetes-best-practices-job-hostalias:
      kubernetes-best-practices-job-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-replicaset"
    scoring_queries:
      kubernetes-best-practices-replicaset-requestcpu:
      kubernetes-best-practices-replicaset-requestmemory:
      kubernetes-best-practices-replicaset-livenessprobe:
      kubernetes-best-practices-replicaset-readinessProbe:
      kubernetes-best-practices-replicaset-hostalias:
      kubernetes-best-practices-replicaset-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-daemonset"
    scoring_queries:
      kubernetes-best-practices-daemonset-requestcpu:
      kubernetes-best-practices-daemonset-requestmemory:
      kubernetes-best-practices-daemonset-livenessprobe:
      kubernetes-best-practices-daemonset-readinessProbe:
      kubernetes-best-practices-daemonset-hostalias:
      kubernetes-best-practices-daemonset-default-namespace:
    data_queries:
  - asset_filter:
      query: platform.name == "k8s-pod"
    scoring_queries:
      kubernetes-best-practices-pod-requestcpu:
      kubernetes-best-practices-pod-requestmemory:
      kubernetes-best-practices-pod-livenessprobe:
      kubernetes-best-practices-pod-readinessProbe:
      kubernetes-best-practices-pod-hostalias:
      kubernetes-best-practices-pod-no-owner:
      kubernetes-best-practices-pod-default-namespace:
    data_queries:
      # kubernetes-best-practices-gather-pods-security-context:
      # kubernetes-best-practices-gather-deployment-container:
      # kubernetes-best-practices-gather-daemonset-container:
      # kubernetes-best-practices-gather-statefulset-container:
      # kubernetes-best-practices-gather-job-container:
      # kubernetes-best-practices-gather-cronjob-container:
queries:
- uid: kubernetes-best-practices-pod-no-owner
  title: Pods should have an owner
  severity: 50
  docs:
    desc: |
      Pods without an owner (ie ReplicaSet, Job, etc) will not be automatically restarted in the event of a Pod crash or Node failure.
    audit: |
      Check for Pods without an owner reference. Any line of output starting with '0' will indiate a Pod that has no owner:

      ```kubectl get pods -A -o json | jq -r '.items[] | [(.metadata.ownerReferences | length), .metadata.namespace, .metadata.name] | @tsv'```
    remediation: |
      For each Pod without an owner, ensure the Pod is owned by an appropriate Kubernetes object (eg Deployment, Job, DaemonSet, etc) that will manage relaunching the Pod in the event of a failure.
  query: |
    # @msg Pod ${ _.name } should be managed by an appropriate Kubernetes object (eg Deployment, Job, DaemonSet, etc)
    k8s.pod {
      manifest['metadata']['ownerReferences'] != null && manifest['metadata']['ownerReferences'].length > 0
    }
- uid: kubernetes-best-practices-pod-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.pod {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-cronjob-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.cronjob {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-statefulset-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.statefulset {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-deployment-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.deployment {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-job-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.job {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-replicaset-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.replicaset {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-daemonset-requestcpu
  title: Container should request CPU
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much CPU a container needs.
    audit: |
      Check for the existence of CPU `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
    remediation: |
      Define the required resources for CPU `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                cpu: "250m"
      ```
  refs:
    - title: Resource Management for Pods and Containers
      url: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  query: |
    k8s.daemonset {
      initContainers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set CPU requests
        resources['requests']['cpu'] != null
      }
    }
- uid: kubernetes-best-practices-pod-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.pod { 
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-cronjob-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.cronjob {
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-statefulset-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.statefulset {
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-deployment-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.deployment {
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers {
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-job-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.job {
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-replicaset-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.replicaset {
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-daemonset-requestmemory
  title: Container should request memory
  severity: 20
  docs:
    desc: |
      When defining a Pod, you should specify how much memory a container needs.
    audit: |
      Check for the existence of memory `requests` resources.
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
    remediation: |
      Define the required resources for memory `requests` in the container spec: 
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: app
            image: images.my-company.example/app:v1
            resources:
              requests:
                memory: "1Gi"
      ```
  query: |
    k8s.daemonset { 
      initContainers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
      containers { 
        # @msg Container ${ _.name  } should set memory requests
        resources['requests']['memory'] != null
      }
    }
- uid: kubernetes-best-practices-pod-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.pod {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-cronjob-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.cronjob {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-statefulset-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.statefulset {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-deployment-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.deployment {
      containers {
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-job-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.job {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-replicaset-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.replicaset {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-daemonset-livenessprobe
  title: Container should configure a livenessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `livenessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            livenessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.daemonset {
      containers { 
        probeSpecified = livenessProbe['httpGet'] != null || livenessProbe['tcpSocket'] != null || livenessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a livenessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-pod-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.pod {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-cronjob-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.cronjob {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-statefulset-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.statefulset {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-deployment-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.deployment {
      containers {
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-job-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.job {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-replicaset-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.replicaset {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-daemonset-readinessProbe
  title: Container should configure a readinessProbe
  severity: 20
  docs:
    audit: |
      Check for the existence of `readinessProbe`:
      
      ```yaml
      ---
      apiVersion: v1
      kind: Pod
      spec:
        containers:
          - name: container-name
            image: index.docker.io/yournamespace/repository
            readinessProbe:
              tcpSocket:
                port: 8080
              initialDelaySeconds: 5
              periodSeconds: 5
      ```
  query: |
    k8s.daemonset {
      containers { 
        probeSpecified = readinessProbe['httpGet'] != null || readinessProbe['tcpSocket'] != null || readinessProbe['exec'] != null

        # @msg Container ${ _.name  } should set a readinessProbe
        probeSpecified == true
      }
    }
- uid: kubernetes-best-practices-pod-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.pod {
      podSpec['hostAliases'] == null
    }
- uid: kubernetes-best-practices-cronjob-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.cronjob {
      manifest['spec']['jobTemplate']['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-statefulset-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.statefulset {      
      manifest['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-deployment-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Deployment
      spec:
        ...
        spec:
          hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
          containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.deployment {
      manifest['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-job-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.job {      
      manifest['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-replicaset-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.replicaset {      
      manifest['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-daemonset-hostalias
  title: Pod should not define hostAliases
  docs:
    desc: |
      DNS entries shouldn't be managed locally via `/etc/hosts` within pods. This can result in unintended and/or dangerous outcomes.
    audit: |
      Check for the existence of `hostAliases` setting in `spec`:

      ```yaml
      apiVersion: v1
      kind: Pod
      spec:
        hostAliases:
          - ip: "127.0.0.1"
            hostnames:
              - "foo.local"
              - "bar.local"
        containers:
          - name: example-app
            image: index.docker.io/yournamespace/repository
      ```
  refs:
    - title: Adding entries to Pod /etc/hosts with HostAliases
      url: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  query: |
    k8s.daemonset {      
      manifest['spec']['template']['spec']['hostAliases'] == null
    }
- uid: kubernetes-best-practices-pod-default-namespace
  title: Workloads should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no Pods:

      ```yaml
      kubectl get pods -n default
      ```
    remediation: |
      For any Pods running in the default Namespace, update/redeploy the Pods (or the parent Deployment, CronJob, etc) to a non-default Namespace:

      ```yaml
      apiVersion:v1
      kind: Pod
      metadata:
        name: examplePod
        namespace: pod-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.pod {
      namespace != "default"
    }
- uid: kubernetes-best-practices-daemonset-default-namespace
  title: DaemonSets should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no DaemonSets:

      ```yaml
      kubectl get daemonsets -n default
      ```
    remediation: |
      For any Daemonsets running in the default Namespace, update/redeploy the DaemonSets to a non-default Namespace:

      ```yaml
      apiVersion:apps/v1
      kind: DaemonSet
      metadata:
        name: exampleDaemonSet
        namespace: daemonset-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.daemonset {
      namespace != "default"
    }
- uid: kubernetes-best-practices-replicaset-default-namespace
  title: ReplicaSets should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no ReplicaSets:

      ```yaml
      kubectl get replicasets -n default
      ```
    remediation: |
      For any ReplicaSets running in the default Namespace, update/redeploy the ReplicaSets (or the parent Deployment) to a non-default Namespace:

      ```yaml
      apiVersion:apps/v1
      kind: ReplicaSet
      metadata:
        name: exampleReplicaSet
        namespace: replicaset-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.replicaset {
      namespace != "default"
    }
- uid: kubernetes-best-practices-job-default-namespace
  title: Jobs should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no Jobs:

      ```yaml
      kubectl get jobs -n default
      ```
    remediation: |
      For any Jobs running in the default Namespace, update/redeploy the Jobs (or the parent CronJobs) to a non-default Namespace:

      ```yaml
      apiVersion:batch/v1
      kind: Job
      metadata:
        name: exampleJob
        namespace: job-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.job {
      namespace != "default"
    }
- uid: kubernetes-best-practices-deployment-default-namespace
  title: Deployments should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no Deployments:

      ```yaml
      kubectl get deployments -n default
      ```
    remediation: |
      For any Deployments running in the default Namespace, update/redeploy the Deployments to a non-default Namespace:

      ```yaml
      apiVersion:apps/v1
      kind: Deployment
      metadata:
        name: exampleDeployment
        namespace: deployment-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.deployment {
      namespace != "default"
    }
- uid: kubernetes-best-practices-statefulset-default-namespace
  title: StatefulSets should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no StatefulSets:

      ```yaml
      kubectl get statefulsets -n default
      ```
    remediation: |
      For any StatefulSets running in the default Namespace, update/redeploy the StatefulSets to a non-default Namespace:

      ```yaml
      apiVersion:apps/v1
      kind: StatefulSet
      metadata:
        name: exampleStatefulset
        namespace: statefulset-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.statefulset {
      namespace != "default"
    }
- uid: kubernetes-best-practices-cronjob-default-namespace
  title: CronJobs should not run in default namespace
  severity: 20
  docs:
    desc: |
      Workloads should be organized by Namespace, and the default Namespace shouldn't be used.
    audit: |
      Check to ensure no workloads are running in the default Namespace. The following command should return no CronJobs:

      ```yaml
      kubectl get cronjob -n default
      ```
    remediation: |
      For any CronJobs running in the default Namespace, update/redeploy the CronJobs to a non-default Namespace:

      ```yaml
      apiVersion:batch/v1
      kind: CronJob
      metadata:
        name: exampleCronJob
        namespace: cronjob-namespace
      ```
  refs:
    - title: "Kubernetes best practices: Organizing with Namespaces"
      url: https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-organizing-with-namespaces
  query: |
    k8s.cronjob {
      namespace != "default"
    }
# Data Queries
- uid: kubernetes-best-practices-gather-deployment-container
  title: Gather all Deployments
  query: |
    k8s.deployments {
      name
    }
- uid: kubernetes-best-practices-gather-daemonset-container
  title: Gather all DaemonSets
  query: |
    k8s.daemonsets {
      name
    }
- uid: kubernetes-best-practices-gather-statefulset-container
  title: Gather all StatefulSets
  query: |
    k8s.statefulsets {
      name
    }
- uid: kubernetes-best-practices-gather-job-container
  title: Gather all Jobs
  query: |
    k8s.jobs {
      name
    }
- uid: kubernetes-best-practices-gather-cronjob-container
  title: Gather all CronJobs
  query: |
    k8s.cronjobs {
      name
    }
- uid: kubernetes-best-practices-gather-pods-security-context
  title: Gather all Pods with security context
  query: |
    k8s.pods {
      name
      namespace
      initContainers {
        name
        resources
        securityContext
      }
      containers {
        name
        resources
        livenessProbe
        securityContext
      }
    }
