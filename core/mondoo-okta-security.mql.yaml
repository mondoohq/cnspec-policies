policies:
  - uid: mondoo-okta-security
    name: Okta Organization Security
    version: 1.0.0
    license: MPL-2.0
    tags:
      mondoo.com/category: security
      mondoo.com/platform: okta-org,saas
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: "## Overview\n\nThe Mondoo Okta Security policy bundle provides security recommendations for Okta organizations.\n\n## Remote scans with cnspec\n\ncnspec can provide on-demand security assessments of infrastructure and services without installing agents or integrations. cnspec connects with and scans a growing number of targets. \n\nFor a complete list, run: \n\n```bash\ncnspec scan --help\n``` \n\n## The cnspec Okta provider\n\nThis policy uses the cnspec Okta provider to authenticate with Okta's API and remotely scan an Okta organization. To learn more, run: \n\n```bash\ncnspec scan okta --help\n```\n\n### Create an API token\n\nThe Okta provider for cnspec requires an API token to authenticate and run scans. To learn how to create an API token, read [Create an API token](https://developer.okta.com/docs/guides/create-an-api-token/main/) in the Okta documentation.\n\n### Configure an OKTA_TOKEN environment variable\n\nYou supply your API token to cnspec using the `OKTA_TOKEN` environment variable. \n\nOn Linux or macOS, run:\n\n```bash\nexport OKTA_TOKEN=<OKTA_TOKEN>\n```\n\nOn Windows, run:\n\n```powershell\n$Env:OKTA_TOKEN = \"<OKTA_TOKEN>\"\n```        \n\n## Scan an Okta organization\n\nTo assess the configuration of an Okta organization, run:\n\n```bash\ncnspec scan okta --organization YOURDOMAIN.okta.com --token $OKTA_TOKEN  --policy-bundle mondoo-okta-security.mql.yaml\n```\n\n## Join the community!\n\nOur goal is to build policies that are simple to deploy, accurate, and actionable. \n\nIf you have suggestions for improving this policy or if you need support, join the [Mondoo community in GitHub Discussions](https://github.com/orgs/mondoohq/discussions).\n"
    groups:
      - filters: asset.platform == "okta" || asset.platform == "okta-org"
        checks:
          - uid: mondoo-okta-security-okta-auth-openid-saml
          - uid: mondoo-okta-security-okta-auth-swa-critical
          - uid: mondoo-okta-security-okta-disable-persist-cookies
          - uid: mondoo-okta-security-okta-enforce-session-lifetime
          - uid: mondoo-okta-security-okta-limit-superadmin
          - uid: mondoo-okta-security-okta-mfa-access
          - uid: mondoo-okta-security-okta-mfa-password-and-another-strong-factor
          - uid: mondoo-okta-security-okta-mfa-password-reauthenticate
          - uid: mondoo-okta-security-okta-mfa-sign-in
          - uid: mondoo-okta-security-okta-mfa-strong-factor
          - uid: mondoo-okta-security-okta-users-unlock
    scoring_system: 2
queries:
  - uid: mondoo-okta-security-okta-mfa-access
    title: Require MFA for all users
    impact: 100
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))
    docs:
      desc: "This check ensures that the MFA is enabled for all users in the Okta tenant. \n"
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use `cnspec shell`__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Security > Global Session Policy**. \n3. Select or add the policy you want to use to require MFA and assign the policy to **Everyone**.\n4. Select **Add rule**. Name the rule and set **Multifactor Authentication (MFA)** to **Required**. Then select **Create Rule**. For more information, read [Add a global session policy rule](https://help.okta.com/oie/en-us/Content/Topics/identity-engine/policies/add-okta-sign-on-policy-rule.htm) in the Okta documentation.\n5. Make sure the status of the rule is **Active**.\n"
  - uid: mondoo-okta-security-okta-enforce-session-lifetime
    title: Limit session lifetime and idle
    impact: 80
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))
    docs:
      desc: "The session lifetime determines the maximum idle time of a user's Okta session, and when the session expires. By enforcing a limited session lifetime for users, admins reduce the window of time wherein a malicious third party can try to access a user's applications in an active session.\n\nThis limitation is especially important considering the workforce is no longer strictly confined within the walls of an office. It minimizes the risk of session cookies misuse or hijacking.\n\nThe maximum session lifetime ensures that a session expires after the set amount of time, even if idle time never expires. The user session expires when the user has been inactive on Okta for the set time period, regardless of the maximum Okta session lifetime.\n"
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use `cnspec shell`__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Security > Global Session Policy**.\n3. Select the rule to modify (select the pencil icon).\n4. Under **Session management**, select **Set time limit (Recommended)** and specify one day or lower.\n5. Under **Expire session after user has been idle on Okta for**, specify two hours or lower.\n6. Select **Update rule**.\n"
  - uid: mondoo-okta-security-okta-auth-openid-saml
    title: Use OpenID or SAML authentication for app access
    impact: 80
    mql: |
      okta.applications.all(_.signOnMode == "OPENID_CONNECT" || _.signOnMode == "SAML_2_0")
    docs:
      desc: |
        Okta supports two protocols for handling federated SSO: OpenID Connect (OIDC) and Security Assertion Markup Language (SAML). Your app and use case influence the SSO protocol you choose. For new integrations, OIDC is recommended.

        OIDC is widely used in organizations and everyday scenarios like *Log in with Google*. The OAuth flow is quite different from the SAML flow. The main difference is that (in OIDC) some actions happen in the user's browser, called the front channel, and some occur directly between the client application and the identity provider (the back channel). This reduces the attack surface substantially because the most important requests are sent through the back channel.

        SAML, in the most basic (and the most popular) setup, allows you to pass information about a user between an identity provider and a service provider (client application) through the user's browser (user agent). It does not require a direct connection between the identity provider and the service provider; everything happens through browser redirects. The user requests a signed document that confirms their identity from the identity provider, gets authenticated, and then sends the signed document to the service provider in order to log in. The signed document can also include information about the user's privileges, groups, and so on.

        Read a helpful comparison here: https://developer.okta.com/docs/guides/oin-sso-overview/
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.applications.all(_.signOnMode == "OPENID_CONNECT" ||  _.signOnMode == "SAML_2_0")" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.applications.all(_.signOnMode == "OPENID_CONNECT" ||  _.signOnMode == "SAML_2_0")
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Applications > Applications**. \n3. Select **Create App Integration** or **Browse App Catalog** to see the available apps.\n4. Assign OIDC or SAML. \n"
  - uid: mondoo-okta-security-okta-users-unlock
    title: Prevent users from unlocking themselves
    impact: 60
    mql: "okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\")) \n"
    docs:
      desc: |
        When a non-admin user account is locked due to exceeding the password entry limitation (or for other reasons) Okta must only notify the Okta administrator. Users must not be able to unlock themselves.

        In contrast, you might consider the self-service password recovery for Okta administrators. To learn more, read: https://support.okta.com/help/s/article/How-to-configure-selfservice-account-recovery?language=en_US
      audit: "__Use `cnspec run`__\n\nRun this query:\n\n  ```bash\n  cnspec run okta -c \"okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\"))\" --organization <YOUR-ORG> --token <OKTA_TOKEN>\n  ```\n\n__Use the cnspec shell__\n\n1. Launch the cnspec shell:\n\n  ```bash\n  cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>\n  ```\n\n2. Run this query:\n\n  ```mql\n  okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\")) \n  ```\n"
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Applications > Applications**. \n3. Select **Security > Authenticators** and the password.\n4. Add a new password policy or edit the existing policy. \n5. Select **Add rule**. Name the rule. Under **Users can perform self-service**, make sure **Unlock account** is not selected. Then select **Create Rule**. For more information, read [Configure the Password authenticator](https://help.okta.com/oie/en-us/Content/Topics/identity-engine/authenticators/configure-password.htm) in the Okta documentation."
  - uid: mondoo-okta-security-okta-auth-swa-critical
    title: Disable Secure Web Authentication (SWA) for critical apps
    impact: 60
    mql: |
      okta.applications.none(signOnMode == "AUTO_LOGIN" || signOnMode == "BROWSER_PLUGIN")
    docs:
      desc: "Secure Web Authentication (SWA) is an Okta technology that provides single sign-on (SSO) capability to external web applications that don't support federated protocols.\n\nAdministrators can set the credentials for the application or the end user can enter a specific username and password. Okta keeps the credentials for that application inside a secure store, encrypted with strong AES-256 encryption. After setting the credentials, end users only need to authenticate with Okta, and then they can SSO directly into the application. \n\nSimplified, SWA is basically a password safe that acts like a password manager by saving the password in the application directly, and Okta knows what that password is. \n\nIt's always recommended to use OpenID for critical applications when SAML is not possible.\n"
      audit: "__Use `cnspec run`__\n\nRun this query:\n\n  ```bash\n  cnspec run okta -c \"okta.applications.none(signOnMode == \"AUTO_LOGIN\" || signOnMode == \"BROWSER_PLUGIN\")\" --organization <YOUR-ORG> --token <OKTA_TOKEN>\n  ```\n\n__Use the cnspec shell__\n\n1. Launch the cnspec shell:\n\n  ```bash\n  cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>\n  ```\n\n2. Run this query:\n\n  ```mql\n  okta.applications.none(signOnMode == \"AUTO_LOGIN\" || signOnMode == \"BROWSER_PLUGIN\" ) \n  ```\n"
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Applications > Applications**. \n3. Select **Create App Integration** or **Browse App Catalog** to see the available apps.\n4. Integrate the app with OpenID or SAML.\n4. Assign users to the app.\n"
  - uid: mondoo-okta-security-okta-mfa-sign-in
    title: Enforce MFA for every sign-in
    impact: 40
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))
    docs:
      desc: "To maximize your security posture, force users to use MFA every time they sign in. \n"
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Security > Global Session Policy** \n3. Add a policy or make a change to the default policy. \n4. Assign the policy to **Everyone**.\n5. Select **Add rule** and make sure **Multifactor Authentication (MFA)** is set to **Required**.\n6. Under **Users will be prompted for MFA**, select **At every sign-in**.\n7. Make the status of the rule is **Active**.\n"
  - uid: mondoo-okta-security-okta-disable-persist-cookies
    title: Don't persist session cookies across browser sessions
    impact: 40
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))
    docs:
      desc: "Persisting session cookies across browser sessions means that when a user closes and reopens a browser while a session is still active, they don't need to re-authenticate. \n\nSession cookies (non-persistent cookies) are stored in memory and never written to the disk. Session cookies remain active as long as the browser remains active; once the browser closes, the cookies vanish.\n"
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization as an administrator.\n2. Select **Security > Global Session Policy**. \n3. Edit the rules related to the policy (as well as default policy): under **Persist session cookies across browser sessions**, select **Disabled**.\n6. When you're finished, update the rule. \n"
  - uid: mondoo-okta-security-okta-limit-superadmin
    title: Limit the organization to three super administrators
    impact: 80
    mql: |
      okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3
    docs:
      desc: |
        The super admin role has the highest permissions of all the admins in Okta. Super admins can create other admins, assign or remove permissions, and perform all other admin activities. Limiting the number of administrators with this level of permissions can reduce the odds of a bad actor gaining access to one of these highly privileged accounts.
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3
          ```
      remediation: "### Use the Okta Admin Console\n\n1. Log into the organization using a super admin account.\n2. Select **Security > Administrators**. \n3. Select the **Admins** column and remove users with the **Super Administrator** role.\n"
  - uid: mondoo-okta-security-okta-mfa-strong-factor
    title: Use strong MFA factors
    impact: 100
    mql: |
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))
    docs:
      desc: |
        While MFA is the ultimate way to add additional security and defend against credential-based attacks, not all MFA factors are secure.

        Traditionally popular factors like "security questions" and SMS have proven problematic. Bad actors can easily find the answers to security questions online, and SMS can leave users vulnerable to phishing and SIM jacking attacks.

        To increase security, require users to authenticate using strong factors like software-based authenticators. Ensure no one uses phone or email authenticators.
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))
          ```
      remediation: |
        ### Use the Okta Admin Console

        1. Log into the organization using a super admin account.
        2. Select **Security > Authentication Policies** and then select **MFA**.
        3. By default, there is a "Catch-all Rule" you can edit, or you can add a new rule.
        4. Select **Actions > Edit**.
        5. Select **Possession factor constraints are > Exclude phone and email authenticators**.
        6. Select **Save**.
  - uid: mondoo-okta-security-okta-mfa-password-and-another-strong-factor
    title: Use password/IdP plus another factor for MFA
    impact: 100
    mql: |
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))
    docs:
      desc: |
        A key goal for MFA is to add additional authentication factors to increase security.
        There are three common types of authentication factors used to authenticate users:
          * Knowledge -  Something you know, such as a password.
          * Possession - Something you have, such as a security key or Authenticator App
          * Inherence -  Something you are, such as a unique biometric or behavioral characteristic

        Among the options that Okta currently offers for MFA, the combination of password/IdP plus another factor is the best practice.
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))
          ```
      remediation: |
        ### Use the Okta Admin Console

        1. Log into the organization using a super admin account.
        2. Select **Security > Authentication Policies** and then select **MFA**.
        3. By default, there is a "Catch-all Rule" you can edit, or you can add a new rule.
        4. Select **Actions > Edit**.
        5. Select **Possession factor constraints are > Exclude phone and email authenticators**.
        6. Select **Save**.
  - uid: mondoo-okta-security-okta-mfa-password-reauthenticate
    title: Enforce a short re-authentication period for password/IdP and MFA
    impact: 60
    mql: |-
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"}))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"}))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S"))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H"))
    docs:
      desc: "Force users to re-enter their password and MFA code periodically. Like most topics in information security, the re-authentication interval has a tradeoff between security and convenience: A short time period is more secure but is inconvenient, while a longer period is more convenient but less secure.\n\nOur recommendation is to configure the password re-authentication after 4 hours and other factor every 8 hours.\n"
      audit: |
        __Use `cnspec run`__

        Run this query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"} ))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"} ))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S" ))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H" ))" --organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        __Use the cnspec shell__

        1. Launch the cnspec shell:

          ```bash
          cnspec shell okta ---organization <YOUR-ORG> --token <OKTA_TOKEN>
          ```

        2. Run this query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"}))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"}))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S"))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H"))
          ```
      remediation: |
        ### Use the Okta Admin Console

        1. Log into the organization using a super admin account.
        2. Select **Security > Authentication Policies** and then select **MFA**.
        3. By default, there is a "Catch-all Rule" you can edit, or you can add a new rule.
        4. Select **Actions > Edit**.
        5. Select **Possession factor constraints are > Exclude phone and email authenticators**.
        6. Select **Save**.
