policies:
  - uid: mondoo-okta-security
    name: Okta Organization Security by Mondoo
    version: 1.0.0
    license: unspecified
    tags:
      mondoo.com/category: security
      mondoo.com/platform: okta-org,saas
    authors:
      - name: Mondoo, Inc
        email: hello@mondoo.com
    docs:
      desc: "# Overview\n\nThe Mondoo Okta Security policy bundle provides security recommendations for Okta organizations.\n\n## About remote scanning\n\nRemote scans with cnspec provide on demand security assessments of infrastructure and services without the need to install any agents or integrations. cnspec comes with a growing list of providers to connect and scan local and remote targets. \n\nA complete list of providers can be found by running the following command: \n\n```bash\ncnspec scan --help\n``` \n\n### cnspec Okta provider\n\nThis policy uses the `okta` provider to authenticate with Okta's API in order to remotely scan an Okta organization. Additional information on the `okta` provider can be found by running the following command: \n\n```bash\ncnspec scan okta --help\n```\n\n## Configuring the Okta provider\n\nThe `okta` provider for cnspec requires an API token to authenticate and run scans. \n\n### Create an API token\n\nTo create an API token, see [Create an API token](https://developer.okta.com/docs/guides/create-an-api-token/main/) on Okta's documentation site.\n\n### Configure a OKTA_TOKEN environment variable\n\nYou supply your API token to cnspec using the `OKTA_TOKEN` environment variable. \n\n#### Linux / macOS\n\n```bash\nexport OKTA_TOKEN=<OKTA_TOKEN>\n```\n\n#### Windows \n\n```powershell\n$Env:OKTA_TOKEN = \"<OKTA_TOKEN>\"\n```        \n\n## Scan an Okta organization\n\nTo scan the configuration of an Okta organization all together:  \n\n```bash\ncnspec scan okta --organization DOMAIN.okta.com --token $OKTA_TOKEN  --policy-bundle mondoo-okta-security.mql.yaml\n```\n\n## Join the community!\n\nOur goal is to build policies that are simple to deploy, accurate, and actionable. \n\nIf you have any suggestions on how to improve this policy, or if you need support, [join the community](https://github.com/orgs/mondoohq/discussions) in GitHub Discussions.\n"
    groups:
      - filters: asset.platform == "okta" || asset.platform == "okta-org"
        checks:
          - uid: mondoo-okta-security-okta-auth-openid-saml
          - uid: mondoo-okta-security-okta-auth-swa-critical
          - uid: mondoo-okta-security-okta-disable-persist-cookies
          - uid: mondoo-okta-security-okta-enforce-session-lifetime
          - uid: mondoo-okta-security-okta-limit-superadmin
          - uid: mondoo-okta-security-okta-mfa-access
          - uid: mondoo-okta-security-okta-mfa-password-and-another-strong-factor
          - uid: mondoo-okta-security-okta-mfa-password-reauthenticate
          - uid: mondoo-okta-security-okta-mfa-sign-in
          - uid: mondoo-okta-security-okta-mfa-strong-factor
          - uid: mondoo-okta-security-okta-users-unlock
queries:
  - uid: mondoo-okta-security-okta-mfa-access
    title: Ensure MFA is active for everybody accessing Okta platform
    impact: 100
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))
    docs:
      desc: "This check ensures that the MFA has been enabled for all users in the Okta tenant. \n"
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["requireFactor"] == true))
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Security the \"Global Session Policy\" \n3. \"Add policy\" in case would like to add specific policy for MFA, otherwise the same procedure can be followed for \"Default Policy\" \n4. Assign the Policy to \"Everyone\"\n5. \"Add rule\", and make sure \"Multifactor Authentication (MFA)\" is set to \"Required\"\n6. You can use the Authentication Policy to define multi-factor requirements. \n7. Make sure at the end the status of the rule is \"Active\"\n"
  - uid: mondoo-okta-security-okta-enforce-session-lifetime
    title: Ensure a limited session lifetime has been enforced
    impact: 80
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))
    docs:
      desc: "Session lifetime determines the maximum idle time of an end user's sign-on session to Okta. By enforcing a limited session lifetime for users, admins reduce the window of time wherein a malicious third party could attempt to access a user's applications from an active session.\n\nThis is especially important considering the workforce is no longer strictly confined to within the walls of an office. This functionality is necessary for any organization with employees, contractors, and partners working from home or other remote locations like coffee shops and airports.\n\nThe maximum session lifetime ensures that a session will expire after this maximum session time, even if idle time never expires. Setting an upper bound minimizes the risk of session cookies misuse or hijacking.\nThe user session will expire when the user has been inactive on Okta for the set time period, regardless of Max Okta session lifetime. \n"
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))" --organization <org-name> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionIdleMinutes"] <= 120))
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["maxSessionLifetimeMinutes"] <= 1440))
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Security the \"Global Session Policy\" \n3. Edit the Rules related to the policy (as well as Default Policy)\n4. In \"Session management\" select \"Set time limit (Recommended)\" and choose one day or less!\n5. In \"Expire session after user has been idle on Okta for\" choose 2 Hours or less!\n6. Update the rule at the end.\n"
  - uid: mondoo-okta-security-okta-auth-openid-saml
    title: Ensure OpenID or SAML authentication are used for app access
    impact: 80
    mql: |
      okta.applications.all(_.signOnMode == "OPENID_CONNECT" || _.signOnMode == "SAML_2_0")
    docs:
      desc: |
        Okta supports two protocols for handling federated SSO. OpenID Connect (OIDC) and Security Assertion Markup Language (SAML). The SSO protocol that you choose to implement your integration with is based on your app and use case. For new integrations, OIDC is recommended.

        OpenID Connect is widely used in organizations and everyday scenarios like “Log in with Google”. The OAuth flow is quite different from the SAML flow. The main difference is that some actions happen in the user’s browser, called the front channel, and some occur directly between the Client Application and the Identity Provider (the backchannel).
        This reduces the attack surface substantially as the most important requests are sent through the backchannel.

        SAML, in the most basic (and the most popular) setup, allows you to pass information about a user between an Identity Provider and a Service Provider (Client Application) via the user’s browser (User Agent). It does not require a direct connection between the Identity Provider and the Service Provider – everything happens via browser redirects. The user requests a signed document that confirms their identity from the Identity Provider, gets authenticated, and then sends the signed document to the Service Provider in order to log in. The signed document can also include information about the user’s privileges, groups, etc.

        A useful comparison can be found here, https://developer.okta.com/docs/guides/oin-sso-overview/
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.applications.all(_.signOnMode == "OPENID_CONNECT" ||  _.signOnMode == "SAML_2_0")" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.applications.all(_.signOnMode == "OPENID_CONNECT" ||  _.signOnMode == "SAML_2_0")
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Applications the \"Applications\" \n3. Select \"Create App Integration\" or \"Browse App Catalog\" to see the available apps.\n4. At the end, users must be assigned to the App. \n"
  - uid: mondoo-okta-security-okta-users-unlock
    title: Ensure normal Users cannot Unlock themselves
    impact: 60
    mql: "okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\")) \n"
    docs:
      desc: |
        A user account that has been locked due to exceeding the password entry limitation, or for other reasons, should only notify the Okta administrator. Users should not be able to unlock themselves.

        In contrast, the self-service password recovery might be considered for Okta Admins, https://support.okta.com/help/s/article/How-to-configure-selfservice-account-recovery?language=en_US
      audit: "__cnspec run__\n\nTo audit Okta `cnspec run`:\n\nRun the following query:\n\n  ```bash\n  cnspec run okta -c \"okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\"))\" --organization <org-name> --token <OKTA_TOKEN>\n  ```\n\n__cnspec shell__\n\nTo audit Okta with `cnspec shell`:\n\n1. Launch `cnspec shell`:\n\n  ```bash\n  cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>\n  ```\n\n2. Run the following query:\n\n  ```mql\n  okta.policies.password.all(_.rules.all(actions[\"selfServiceUnlock\"][\"access\"] == \"DENY\")) \n  ```\n"
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as an administrator to the related Okta organization (Identity Engine)\n2. Select from Applications the \"Applications\" \n3. Select from Security the \"Authenticators\" and the password\n4. You can add a new password policy by selecting \"Add New Password Policy\" or edit the existing policy. \n5. Select \"Add rule\" and make sure under \"Users can perform self-service\", the \"Unlock account\" has been not selected. \n6. Update the rule and you are done!\n"
  - uid: mondoo-okta-security-okta-auth-swa-critical
    title: Ensure Secure Web Authentication (SWA) is disabled for critical apps
    impact: 60
    mql: |
      okta.applications.none(signOnMode == "AUTO_LOGIN" || signOnMode == "BROWSER_PLUGIN")
    docs:
      desc: "Secure Web Authentication (SWA) is an Okta technology that provides Single Sign-On (SSO) functionality to external web applications that don't support federated protocols.\n\nAdministrators can set the credentials for the application, or the end user can enter a specific username and password. Okta keeps the credentials for that application inside a secure store, encrypted with strong AES-256  encryption. After setting the credentials, end users only need to authenticate with Okta, and then they can SSO directly into the application. \n\nIn simple terms, SWA is basically a password safe that acts like a password manager by saving the password in the application directly, and Okta knows what that password is. \n\nIt is always recommended to use OpenID for critical applications when SAML is not possible.\n"
      audit: "__cnspec run__\n\nTo audit Okta `cnspec run`:\n\nRun the following query:\n\n  ```bash\n  cnspec run okta -c \"okta.applications.none(signOnMode == \"AUTO_LOGIN\" || signOnMode == \"BROWSER_PLUGIN\")\" --organization <org-name> --token <OKTA_TOKEN>\n  ```\n\n__cnspec shell__\n\nTo audit Okta with `cnspec shell`:\n\n1. Launch `cnspec shell`:\n\n  ```bash\n  cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>\n  ```\n\n2. Run the following query:\n\n  ```mql\n  okta.applications.none(signOnMode == \"AUTO_LOGIN\" || signOnMode == \"BROWSER_PLUGIN\" ) \n  ```\n"
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Applications the \"Applications\" \n3. Select \"Create App Integration\" or \"Browse App Catalog\" to see the available apps.\n4. Integrate the app with OpenID or SAML.\n4. At the end, the users must be assigned to the App.\n"
  - uid: mondoo-okta-security-okta-mfa-sign-in
    title: Ensure the option "at every sign-in" has been enabled for MFA
    impact: 40
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))
    docs:
      desc: "It is recommended in order to maximize the security posture, the MFA happens at every sign-in attempt. \n"
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["factorPromptMode"] == "ALWAYS"))
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Security the \"Global Session Policy\" \n3. \"Add policy\" in case would like to add specific policy for MFA, otherwise the same procedure can be followed for \"Default Policy\" \n4. Assign the Policy to \"Everyone\"\n5. Select \"Add rule\" and make sure \"Multifactor Authentication (MFA)\" is set to \"Required\"\n6. Under \"Users will be prompted for MFA\" select \"At every sign-in\"\n7. Make sure at the end the status of the rule is \"Active\"\n"
  - uid: mondoo-okta-security-okta-disable-persist-cookies
    title: Ensure Persist session cookies across browser sessions is disabled
    impact: 40
    mql: |
      okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))
    docs:
      desc: "If enabled, when a user reopens the same browser, they will not be asked to sign-in again if the session is still active. \n\nSession Cookies (Non-Persistent cookies) are stored in memory and never written to the disk. Session cookies remain active as long as the browser remains active – once the browser is closed, the cookies vanish.\n"
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.signOn.where(_.rules.all(status == "ACTIVE")).all(_.rules.all(actions["signon"]["session"]["usePersistentCookie"] == false))
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Administrator to the related Okta organization (Identity Engine)\n2. Select from Security the \"Global Session Policy\" \n3. Edit the Rules related to the policy (as well as Default Policy)\n5. Under \"Persist session cookies across browser sessions, \" select \"Disabled\"\n6. Update rule at the end. \n"
  - uid: mondoo-okta-security-okta-limit-superadmin
    title: Ensure the users with Super Admin rights are limited to 3
    impact: 80
    mql: |
      okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3
    docs:
      desc: |
        The Super Admin role has the highest permissions of all the admins in Okta. Super Admins can create other admins, assign or remove permissions, and perform all other admin activities.
        Limiting the number of administrators with this level of permissions can reduce the odds of a bad actor gaining access to one of these highly privileged accounts.
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.users.where(roles.all(type == "SUPER_ADMIN")).length <= 3
          ```
      remediation: "### Okta Console\n\nTo update via the Okta portal:\n1. Log in as Super Admin to the related Okta organization (Identity Engine)\n2. Select from Security the \"Administrators\" \n3. Select the \"Admins\" column and remove the users with \"Super Administrator\" role if needed\n"
  - uid: mondoo-okta-security-okta-mfa-strong-factor
    title: Ensure the strong Factors is used for MFA
    impact: 100
    mql: |
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))
    docs:
      desc: |
        While MFA is the ultimate way to add additional security and defend against credential-based attacks, not all factors in multi-factor authentication are safe and secure.

        Traditionally popular factors like "security questions" and sms have proven problematic. Bad actors can easily find the answers to security questions online, and SMS can leave users vulnerable to phishing and SIM jacking attacks.

        To increase security administrators should require users to authenticate via strong factors, like software-based authenticators, and ensure no one uses phone or email authenticators.
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED"} ))
          ```
      remediation: |
        ### Okta Console

        To update via the Okta portal:
        1. Log in as Super Admin to the related Okta organization (Identity Engine)
        2. Select from Security the "Authentication Policies" and then select "MFA"
        3. By default, there is a "Catch-all Rule" which can be edited or Add a new Rule
        4. Select "Actions" and then "Edit"
        5. In the section, select "Possession factor constraints are" and "Exclude phone and email authenticators"
        6. When complete select "Save"
  - uid: mondoo-okta-security-okta-mfa-password-and-another-strong-factor
    title: Ensure that MFA is configured to use password/IdP plus another authentication factor
    impact: 100
    mql: |
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))
    docs:
      desc: |
        A key goal for MFA is to add additional authentication factors to increase security.
        There are three common types of authentication factors used to authenticate users:
          * Knowledge -  Something you know, such as a password.
          * Possession - Something you have, such as a security key or Authenticator App
          * Inherence -  Something you are, such as a unique biometric or behavioral characteristic

        Among the options that Okta currently offers in MFA configuration part, the combination of Password/IdP plus another factor is the best practice.
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))" --organization <org-name> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["possession"]["deviceBound"] == "REQUIRED" }))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["factorMode"] == "2FA"))
          ```
      remediation: |
        ### Okta Console

        To update via the Okta portal:
        1. Log in as Super Admin to the related Okta organization (Identity Engine)
        2. Select from Security the "Authentication Policies" and then select "MFA"
        3. By default, there is a "Catch-all Rule" which can be edited or Add a new Rule.
        4. Select "Actions" and then "Edit"
        5. In the section select "Possession factor constraints are" and "Exclude phone and email authenticators"
        6. When complete, select "Save"
  - uid: mondoo-okta-security-okta-mfa-password-reauthenticate
    title: Ensure the re-authentication period for Password/IdP and MFA code is active and short
    impact: 60
    mql: |-
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"}))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"}))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S"))
      okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H"))
    docs:
      desc: "The best practice is to prompt the user to re-enter their password and MFA code periodically. Like most topics in information security, the re-authentication interval has a tradeoff between security and convenience: a short amount has better security but is inconvenient, while a longer amount is more convenient but has lower security.\n\nIt should be tested that following two options never being configured for password and other factors: \n  * Every sign-in attempt\n  * Never re-authenticate if the session is active \n\n  Our recommendation is to configure the password re-authentication after 4 hours and other factor every 8 hours.\n"
      audit: |
        __cnspec run__

        To audit Okta `cnspec run`:

        Run the following query:

          ```bash
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"} ))" --organization <org-name> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"} ))" --organization <org-name> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S" ))" --organization <org-name> --token <OKTA_TOKEN>
          cnspec run okta -c "okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H" ))" --organization <org-name> --token <OKTA_TOKEN>
          ```

        __cnspec shell__

        To audit Okta with `cnspec shell`:

        1. Launch `cnspec shell`:

          ```bash
          cnspec shell okta ---organization <org-name> --token <OKTA_TOKEN>
          ```

        2. Run the following query:

          ```mql
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT0S"}))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["constraints"] { _["knowledge"]["reauthenticateIn"] != "PT43800H"}))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT0S"))
          okta.policies.accessPolicy.where(name == "MFA").all(rules.all(actions["appSignOn"]["verificationMethod"]["reauthenticateIn"] != "PT43800H"))
          ```
      remediation: |
        ### Okta Console

        To update via the Okta portal:
        1. Log in as Super Admin to the related Okta organization (Identity Engine)
        2. Select from Security the "Authentication Policies" and then select "MFA"
        3. By default, there is a "Catch-all Rule" which can be edited or Add a new Rule
        4. Select "Actions" and then "Edit"
        5. In the Section "Possession factor constraints are", the "Exclude phone and email authenticators" should be selected.
        6. When complete select "Save"
